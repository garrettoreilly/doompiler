module Parser
    ( parseProgram
    ) where

import Lexer
import Control.Applicative

-- | The parseProgram function kicks off the parser.
--   It receives the token list generated by the lexer as a parameter.
--   Returns a boolean: True if it parsed successfully, error otherwise.
parseProgram :: [Token] -> Bool
parseProgram xs = case findBlock xs of
                      [Token EOF _ _ _] -> True
                      (y:ys) -> error $ value y ++ show (kind (head ys)) ++ "\nLine " ++ show (line (head ys)) ++ ", position " ++ show (position (head ys))

-- | compareList identifies which of the optional terminals succeeded in matching at least one token
--   and returns the token list from that path.
compareList :: [Token] -> [[Token]] -> [Token]
compareList ts [] = Token Error "Error! Invalid token, received " 0 0 : ts
compareList ts (x:xs)
    | kind (head x) /= Error = x
    | tail x == tail ts && kind (head ts) == Digit = compareList ts xs
    | tail x /= ts = x
    | tail x == ts = compareList ts xs

-- | The following "get" functions attempt to consume the first element
--   of the token list they receive as a parameter.
--   If the first token is an error token, they return the whole token list.
--   If they successfully consume a token, they return the rest of the list.
--   Otherwise, they prepend an error token denoting a mismatched token.
getOpenBrace :: [Token] -> [Token]
getOpenBrace all@(Token Error _ _ _ : xs) = all
getOpenBrace (Token OpenBrace _ _ _ : xs) = xs
getOpenBrace xs = Token Error "Error! Expected open brace, received " 0 0 : xs

getCloseBrace :: [Token] -> [Token]
getCloseBrace all@(Token Error _ _ _ : xs) = all
getCloseBrace (Token CloseBrace _ _ _ : xs) = xs
getCloseBrace xs = Token Error "Error! Expected close brace, received " 0 0 : xs

getOpenParen :: [Token] -> [Token]
getOpenParen all@(Token Error _ _ _ : xs) = all
getOpenParen (Token OpenParen _ _ _ : xs) = xs
getOpenParen xs = Token Error "Error! Expected open paren, received " 0 0 : xs

getCloseParen :: [Token] -> [Token]
getCloseParen all@(Token Error _ _ _ : xs) = all
getCloseParen (Token CloseParen _ _ _ : xs) = xs
getCloseParen xs = Token Error "Error! Expected close paren, received " 0 0 : xs

getAssignOp :: [Token] -> [Token]
getAssignOp all@(Token Error _ _ _ : xs) = all
getAssignOp (Token AssignOp _ _ _ : xs) = xs
getAssignOp xs = Token Error "Error! Expected assignment operator, received " 0 0 : xs

getId :: [Token] -> [Token]
getId all@(Token Error _ _ _ : xs) = all
getId (Token Id _ _ _ : xs) = xs
getId xs = Token Error "Error! Expected ID, received " 0 0 : xs

getIdType :: [Token] -> [Token]
getIdType all@(Token Error _ _ _ : xs) = all
getIdType (Token IdType _ _ _ : xs) = xs
getIdType xs = Token Error "Error! Expected ID type, received " 0 0 : xs

getStringExpr :: [Token] -> [Token]
getStringExpr all@(Token Error _ _ _ : xs) = all
getStringExpr (Token CharList _ _ _ : xs) = xs
getStringExpr xs = Token Error "Error! Expected string, received " 0 0 : xs

getBoolVal :: [Token] -> [Token]
getBoolVal all@(Token Error _ _ _ : xs) = all
getBoolVal (Token Boolean _ _ _ : xs) = xs
getBoolVal xs = Token Error "Error! Expected boolean value, received " 0 0 : xs

getBoolOp :: [Token] -> [Token]
getBoolOp all@(Token Error _ _ _ : xs) = all
getBoolOp (Token BoolOp _ _ _ : xs) = xs
getBoolOp xs = Token Error "Error! Expected boolean operator, received " 0 0 : xs

getDigit :: [Token] -> [Token]
getDigit all@(Token Error _ _ _ : xs) = all
getDigit (Token Digit _ _ _ : xs) = xs
getDigit xs = Token Error "Error! Expected digit, received " 0 0 : xs

getIntOp :: [Token] -> [Token]
getIntOp all@(Token Error _ _ _ : xs) = all
getIntOp (Token IntOp _ _ _ : xs) = xs
getIntOp xs = Token Error "Error! Expected int operator, received " 0 0 : xs

-- | The following "find" functions expand terminals in the grammar by composing
--   the functions that identify other terminals and non-terminals.
findBlock :: [Token] -> [Token]
findBlock all@(Token Error _ _ _ : xs) = all
findBlock xs = (getCloseBrace . findStatementList . getOpenBrace) xs

findStatementList :: [Token] -> [Token]
findStatementList all@(Token Error _ _ _ : xs) = all
findStatementList all@(Token CloseBrace _ _ _ : xs) = all
findStatementList xs = case findStatement xs of
                           all@(Token Error _ _ _ : ys) -> all
                           ys -> findStatementList ys

findPrint :: [Token] -> [Token]
findPrint (Token Print _ a b : xs) = (getCloseParen . findExpr . getOpenParen) xs
findPrint xs = Token Error "Error! Expected print statement, received " 0 0 : xs

findAssignment :: [Token] -> [Token]
findAssignment = findExpr . getAssignOp . getId

findVarDecl :: [Token] -> [Token]
findVarDecl = getId . getIdType

findWhile :: [Token] -> [Token]
findWhile (Token While _ a b : xs) = (findBlock . findBoolExpr) xs
findWhile xs = Token Error "Error! Expected while statement, received " 0 0 : xs

findIf :: [Token] -> [Token]
findIf (Token If _ a b : xs) = (findBlock . findBoolExpr) xs
findIf xs = Token Error "Error! Expected if statement, received " 0 0 : xs

-- | These last functions call the "optional" token locator functions with the current
--   token list and return the resulting list of token lists to compareList.
findStatement :: [Token] -> [Token]
findStatement xs = compareList xs $ [findBlock, findIf, findWhile, findVarDecl, findAssignment, findPrint] <*> [xs]

findExpr :: [Token] -> [Token]
findExpr all@(Token Error _ _ _ : xs) = all
findExpr xs = compareList xs $ [findIntExpr, getStringExpr, findBoolExpr, getId] <*> [xs]

findBoolExpr :: [Token] -> [Token]
findBoolExpr all@(Token Error _ _ _ : xs) = all
findBoolExpr xs = compareList xs $ [getCloseParen . findExpr . getBoolOp . findExpr . getOpenParen, getBoolVal] <*> [xs]

findIntExpr :: [Token] -> [Token]
findIntExpr all@(Token Error _ _ _ : xs) = all
findIntExpr xs = compareList xs $ [findExpr . getIntOp . getDigit, getDigit] <*> [xs]
